import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin, testContext } from '../../utils/testQuery';
import { createEntity, createRelation, deleteElementById } from '../../../src/database/middleware';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';
import { BasicStoreEntityExploit, ENTITY_TYPE_EXPLOIT } from '../../../src/modules/exploit/exploit-types';
import { listEntitiesPaginated, storeLoadById } from '../../../src/database/middleware-loader';
import { EXPLOIT_DEFINITION } from '../../../src/modules/exploit/exploit';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../../../src/schema/general';
import {
  attackPatternInput,
  campaignInput,
  EntityInput,
  EntityType,
  exploitInput,
  intrusionSetInput,
  malwareInput,
  markingInput,
  threatActorInput,
  vulnerabilityInput
} from './exploit-test-fixtures';
import type { BasicStoreEntity } from '../../../src/types/store';
import type { MarkingDefinition } from '../../../src/generated/graphql';
import { addMarkingDefinition } from '../../../src/domain/markingDefinition';

async function findEntityByName(entityName: string, entityType: any): Promise<BasicStoreEntity | undefined> {
  const entity = await listEntitiesPaginated(testContext, ADMIN_USER, [entityType], { search: `"${entityName}"` });

  return entity.edges.length >= 0 ? entity.edges[0].node : undefined;
}

async function relateTwoEntities(entityPredecessor: any, relationType: string, entitySuccessor: any) {
  await createRelation(
    testContext,
    ADMIN_USER,
    {
      fromId: entityPredecessor.id,
      relationship_type: relationType,
      toId: entitySuccessor.id
    }
  );
}

async function createEntityInTestContext(entityInput: EntityInput): Promise<any> {
  return createEntity(testContext, ADMIN_USER, entityInput.data, entityInput.type);
}

async function cascadeDeleteEntityInTestContext(anEntity: any) {
  await deleteElementById(testContext, ADMIN_USER, anEntity.id, ABSTRACT_STIX_DOMAIN_OBJECT);
}

describe('Exploit', () => {
  let anExploit: BasicStoreEntityExploit;
  let aMarking: MarkingDefinition;
  let aThreatActor: any;
  let aVulnerability: any;
  let anAttackPattern: any;
  let anIntrusionSet: any;
  let aCampaign: any;
  let aMalware: any;

  beforeAll(async () => {
    anExploit = await createEntityInTestContext(exploitInput);

    aMarking = await addMarkingDefinition(testContext, ADMIN_USER, markingInput);

    aThreatActor = await createEntityInTestContext(threatActorInput);
    await relateTwoEntities(aThreatActor, RELATION_USES, anExploit);

    aVulnerability = await createEntityInTestContext(vulnerabilityInput);
    await relateTwoEntities(anExploit, RELATION_TARGETS, aVulnerability);

    anAttackPattern = await createEntityInTestContext(attackPatternInput);
    await relateTwoEntities(anExploit, RELATION_USES, anAttackPattern);

    anIntrusionSet = await createEntityInTestContext(intrusionSetInput);
    await relateTwoEntities(anIntrusionSet, RELATION_USES, anExploit);

    aCampaign = await createEntityInTestContext(campaignInput);
    await relateTwoEntities(aCampaign, RELATION_USES, anExploit);

    aMalware = await createEntityInTestContext(malwareInput);
    await relateTwoEntities(aMalware, RELATION_USES, anExploit);
  });

  afterAll(async () => {
    await cascadeDeleteEntityInTestContext(anExploit);
    await cascadeDeleteEntityInTestContext(aMarking);
    await cascadeDeleteEntityInTestContext(aThreatActor);
    await cascadeDeleteEntityInTestContext(aVulnerability);
    await cascadeDeleteEntityInTestContext(anAttackPattern);
    await cascadeDeleteEntityInTestContext(anIntrusionSet);
    await cascadeDeleteEntityInTestContext(aCampaign);
    await cascadeDeleteEntityInTestContext(aMalware);
  });

  describe('attributes', () => {
    const attributeNames = EXPLOIT_DEFINITION.attributes.map((attribute) => attribute.name);

    it('has a name', () => {
      expect(attributeNames).toContain('name');
    });

    it('has a description', () => {
      expect(attributeNames).toContain('description');
    });

    it('has a published_date', () => {
      expect(attributeNames).toContain('published_date');
    });
  });

  describe('creation', () => {
    const exploitName = 'an Exploit';

    afterEach(async () => {
      const exploit = await findEntityByName(exploitName, EntityType.exploit);

      if (exploit !== undefined) {
        await cascadeDeleteEntityInTestContext(exploit);
      }
    });

    it('can be created', async () => {
      const exploitInputForCreation = {
        name: exploitName,
        description: 'an exploit description',
        published_date: '2023-01-16T15:54:59.194Z'
      };

      const query: DocumentNode = gql`
        mutation ExploitCreation($input: ExploitAddInput!) {
          exploitAdd(input: $input) {
            id
            name
          }
        }
      `;
      const variables = { input: exploitInputForCreation };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploitAdd.name).toEqual(exploitName);
    });
  });

  describe('deletion', () => {
    let anExploitForDeletion: BasicStoreEntityExploit;

    beforeEach(async () => {
      const exploitInputData = {
        name: 'exploit-test_exploit-fixture-for-deletion',
        description: '',
        published_date: new Date('2023-01-16T15:54:59.194Z'),
      };

      anExploitForDeletion = await createEntity(testContext, ADMIN_USER, exploitInputData, exploitInput.type);
    });

    afterEach(async () => {
      const exploit = await storeLoadById(testContext, ADMIN_USER, anExploitForDeletion.id, ENTITY_TYPE_EXPLOIT);

      if (exploit !== undefined) {
        await cascadeDeleteEntityInTestContext(exploit);
      }
    });

    it('can be deleted', async () => {
      const query: DocumentNode = gql`
        mutation ExploitDelete($id: ID!) {
          exploitDelete(id: $id)
        }
      `;
      const variables = { id: anExploitForDeletion.id };

      await queryAsAdmin({ query, variables });
      const deletedExploit = await storeLoadById(testContext, ADMIN_USER, anExploitForDeletion.id, ENTITY_TYPE_EXPLOIT);

      expect(deletedExploit).toBeUndefined();
    });
  });

  it('is loaded from store with its internal id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: anExploit.id };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(anExploit.id);
  });

  it('can be listed in a collection', async () => {
    const query: DocumentNode = gql`
      query listExploits($first: Int $after: ID $orderBy: ExploitsOrdering $orderMode: OrderingMode
        $filters: [ExploitsFiltering!] $filterMode: FilterMode $search: String) {
        exploits(first: $first after: $after orderBy: $orderBy orderMode: $orderMode
          filters: $filters filterMode: $filterMode search: $search) {
          edges {
            node {
              id
            }
          }
        }
      }
    `;
    const variables = { };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploits.edges.length).toEqual(1);
  });

  it('can have its context updated', async () => {
    const query: DocumentNode = gql`
      mutation UpdateExploitContext($id: ID!, $input: EditContext!) {
        exploitContextPatch(id: $id, input: $input) {
          id
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      input: { focusOn: 'description' }
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitContextPatch.id).toEqual(anExploit.id);
  });

  it('can have references', async () => {
    const query: DocumentNode = gql`
      mutation AddSomeReferencesToExploit($id: ID!, $input: StixRefRelationshipAddInput!) {
        exploitRelationAdd(id: $id, input: $input) {
          id
          from {
            ... on Exploit {
              objectMarking {
                edges {
                  node {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      input: {
        toId: aMarking.id,
        relationship_type: 'object-marking'
      }
    };

    const response = await queryAsAdmin({ query, variables });

    const markingDefinitions = response.data?.exploitRelationAdd.from.objectMarking.edges[0].node.id;

    expect(markingDefinitions).toEqual(aMarking.id);
  });

  it('can delete its references', async () => {
    const query: DocumentNode = gql`
      mutation DeleteExploitMarkingReference($id: ID!, $toId: StixRef!, $relationship_type: String!) {
        exploitRelationDelete(id: $id, toId: $toId, relationship_type: $relationship_type) {
          id
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      toId: aMarking.id,
      relationship_type: 'object-marking'
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitRelationDelete.id).toEqual(anExploit.id);
  });

  it('can be used by a threat actor', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on ThreatActor {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aThreatActor.id);
  });

  it('can target a vulnerability', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on Vulnerability {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(aVulnerability.id);
  });

  it('can use an attack pattern', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on AttackPattern {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(anAttackPattern.id);
  });

  it('can be used by an intrusion set', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on IntrusionSet {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(anIntrusionSet.id);
  });

  it('can be used by a campaign', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Campaign {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aCampaign.id);
  });

  it('can be used by a malware', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Malware {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aMalware.id);
  });
});
