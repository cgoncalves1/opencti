import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin } from '../../utils/testQuery';
import { createEntity, createRelation } from '../../../src/database/middleware';
import {
  ENTITY_TYPE_ATTACK_PATTERN, ENTITY_TYPE_INTRUSION_SET, ENTITY_TYPE_MALWARE,
  ENTITY_TYPE_THREAT_ACTOR,
  ENTITY_TYPE_VULNERABILITY
} from '../../../src/schema/stixDomainObject';
import { executionContext } from '../../../src/utils/access';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';

const exploit = {
  stix_id: 'exploit--efb6fbec-d916-11ed-afa1-0242ac120002',
  name: 'an Exploit',
  description: 'an exploit description',
  published_date: '2023-01-16T15:54:59.194Z'
};

describe('Exploit', () => {
  let exploitId: any;

  it('can be created', async () => {
    const exploitCreationQuery: DocumentNode = gql`
      mutation ExploitAdd($input: ExploitAddInput!) {
        exploitAdd(input: $input) {
          id
          standard_id
          name
          description
          published_date
        }
      }
    `;

    const exploitCreationVariables = { input: exploit };

    const creationResponse = await queryAsAdmin({
      query: exploitCreationQuery,
      variables: exploitCreationVariables
    });

    expect(creationResponse.data?.exploitAdd.name).toEqual(exploit.name);

    exploitId = creationResponse.data?.exploitAdd.id;
  });

  it('is loaded from store with its internal id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: exploitId };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(exploitId);
  });

  it('is loaded from store with its stix id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: exploit.stix_id };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(exploitId);
  });

  it('can be deleted', async () => {
    const exploitCreationQuery: DocumentNode = gql`
      mutation ExploitAdd($input: ExploitAddInput!) {
        exploitAdd(input: $input) {
          id
          name
        }
      }
    `;
    const exploitCreationVariables = {
      input: {
        name: 'another Exploit',
        description: 'an exploit to be deleted',
        published_date: '2023-01-16T15:54:59.194Z'
      }
    };
    const creationResponse = await queryAsAdmin({
      query: exploitCreationQuery,
      variables: exploitCreationVariables
    });

    expect(creationResponse.data?.exploitAdd.name).toEqual(exploitCreationVariables.input.name);

    const exploitDeletionQuery: DocumentNode = gql`
      mutation ExploitDelete($id: ID!) {
        exploitDelete(id: $id)
      }
    `;
    const exploitToBeDeletedId = creationResponse.data?.exploitAdd.id;
    const exploitDeletionVariables = { id: exploitToBeDeletedId };

    await queryAsAdmin({
      query: exploitDeletionQuery,
      variables: exploitDeletionVariables
    });

    const loadExploitByIdQuery: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const loadExploitByIdVariables = { id: exploitToBeDeletedId };
    const loadExploitByIdResponse: GraphQLResponse = await queryAsAdmin({ query: loadExploitByIdQuery, variables: loadExploitByIdVariables });

    expect(loadExploitByIdResponse.data?.exploit).toBeNull();
  });

  it('can use an attack pattern', async () => {
    const anAttackPattern = {
      name: 'attack pattern',
      description: 'only meant to be used by an exploit',
      x_mitre_id: '',
      objectLabel: [],
      objectMarking: [],
      killChainPhases: [],
      externalReferences: []
    };
    const attackPatternCreationResponse = await createEntity(executionContext('testing'), ADMIN_USER, anAttackPattern, ENTITY_TYPE_ATTACK_PATTERN);
    const exploitUsesAttackPatternRelationship = {
      relationship_type: RELATION_USES,
      fromId: exploitId,
      toId: attackPatternCreationResponse?.id,
    };
    await createRelation(executionContext('testing'), ADMIN_USER, exploitUsesAttackPatternRelationship);

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on AttackPattern {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(attackPatternCreationResponse.id);
  });

  it('can target a vulnerability', async () => {
    const aVulnerability = {
      name: 'vulnerability',
      description: 'meant to test the target relation with exploit',
      x_opencti_base_score: 1,
      x_opencti_base_severity: '',
      x_opencti_attack_vector: '',
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    };
    const vulnerabilityCreationResponse = await createEntity(executionContext('testing'), ADMIN_USER, aVulnerability, ENTITY_TYPE_VULNERABILITY);
    const exploitTargetsVulnerabilityRelationship = {
      relationship_type: RELATION_TARGETS,
      fromId: exploitId,
      toId: vulnerabilityCreationResponse?.id,
    };
    await createRelation(executionContext('testing'), ADMIN_USER, exploitTargetsVulnerabilityRelationship);

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on Vulnerability {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(vulnerabilityCreationResponse.id);
  });

  it('can be used by a threat actor', async () => {
    const aThreatActor = await createEntity(
      executionContext('testing'),
      ADMIN_USER,
      {
        name: 'threat actor',
        description: 'meant to test the uses relation with exploit',
        threat_actor_type: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_THREAT_ACTOR
    );

    await createRelation(
      executionContext('testing'),
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aThreatActor?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on ThreatActor {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aThreatActor.id);
  });

  it('can be used by an intrusion set', async () => {
    const anIntrusionSet = await createEntity(
      executionContext('testing'),
      ADMIN_USER,
      {
        name: 'intrusion set',
        description: 'meant to test the uses relation with exploit',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_INTRUSION_SET
    );

    await createRelation(
      executionContext('testing'),
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: anIntrusionSet?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on IntrusionSet {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(anIntrusionSet.id);
  });

  it('can be used by a malware', async () => {
    const aMalware = await createEntity(
      executionContext('testing'),
      ADMIN_USER,
      {
        name: 'malware',
        description: 'meant to test the uses relation with exploit',
        malware_types: [],
        is_family: false,
        architecture_execution_envs: [],
        implementation_languages: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_MALWARE
    );

    await createRelation(
      executionContext('testing'),
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aMalware?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Malware {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aMalware.id);
  });
});
