import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { afterEach, describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin, testContext } from '../../utils/testQuery';
import { createEntity, createRelation } from '../../../src/database/middleware';
import {
  ENTITY_TYPE_ATTACK_PATTERN,
  ENTITY_TYPE_CAMPAIGN,
  ENTITY_TYPE_INTRUSION_SET,
  ENTITY_TYPE_MALWARE,
  ENTITY_TYPE_THREAT_ACTOR,
  ENTITY_TYPE_VULNERABILITY
} from '../../../src/schema/stixDomainObject';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';
import { ENTITY_TYPE_EXPLOIT } from '../../../src/modules/exploit/exploit-types';
import { storeLoadById } from '../../../src/database/middleware-loader';

const exploit = {
  stix_id: 'exploit--efb6fbec-d916-11ed-afa1-0242ac120002',
  name: 'an Exploit',
  description: 'an exploit description',
  published_date: '2023-01-16T15:54:59.194Z'
};

async function undoUpdate(exploitId: any) {
  const query: DocumentNode = gql`
    mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
      exploitFieldPatch(id: $id, input: $input) {
        name
      }
    }
  `;
  const variables = {
    id: exploitId,
    input: { key: 'name', value: [exploit.name] }
  };

  await queryAsAdmin({ query, variables });
}

describe('Exploit', () => {
  let exploitId: any;

  it('can be created', async () => {
    const exploitCreationQuery: DocumentNode = gql`
      mutation ExploitAdd($input: ExploitAddInput!) {
        exploitAdd(input: $input) {
          id
          standard_id
          name
          description
          published_date
        }
      }
    `;

    const exploitCreationVariables = { input: exploit };

    const creationResponse = await queryAsAdmin({
      query: exploitCreationQuery,
      variables: exploitCreationVariables
    });

    expect(creationResponse.data?.exploitAdd.name).toEqual(exploit.name);

    exploitId = creationResponse.data?.exploitAdd.id;
  });

  it('is loaded from store with its internal id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: exploitId };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(exploitId);
  });

  it('is loaded from store with its stix id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: exploit.stix_id };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(exploitId);
  });

  it('can be deleted', async () => {
    const exploitName = 'yet another exploit';
    const anExploit = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: exploitName,
        description: 'soon to be deleted',
        published_date: '2023-01-16T15:54:59.194Z'
      },
      ENTITY_TYPE_EXPLOIT
    );

    expect(anExploit.name).toEqual(exploitName);

    const exploitDeletionQuery: DocumentNode = gql`
      mutation ExploitDelete($id: ID!) {
        exploitDelete(id: $id)
      }
    `;
    const exploitToBeDeletedId = anExploit.id;
    const exploitDeletionVariables = { id: exploitToBeDeletedId };

    await queryAsAdmin({
      query: exploitDeletionQuery,
      variables: exploitDeletionVariables
    });

    const deletedExploit = await storeLoadById(testContext, ADMIN_USER, anExploit.id, ENTITY_TYPE_EXPLOIT);

    expect(deletedExploit).toBeUndefined();
  });

  it('can use an attack pattern', async () => {
    const anAttackPattern = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'attack pattern',
        description: 'only meant to be used by an exploit',
        x_mitre_id: '',
        objectLabel: [],
        objectMarking: [],
        killChainPhases: [],
        externalReferences: []
      },
      ENTITY_TYPE_ATTACK_PATTERN
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: exploitId,
        toId: anAttackPattern?.id,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on AttackPattern {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(anAttackPattern.id);
  });

  it('can target a vulnerability', async () => {
    const aVulnerability = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'vulnerability',
        description: 'meant to test the target relation with exploit',
        x_opencti_base_score: 1,
        x_opencti_base_severity: '',
        x_opencti_attack_vector: '',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_VULNERABILITY
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_TARGETS,
        fromId: exploitId,
        toId: aVulnerability?.id,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on Vulnerability {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(aVulnerability.id);
  });

  it('can be used by a threat actor', async () => {
    const aThreatActor = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'threat actor',
        description: 'meant to test the uses relation with exploit',
        threat_actor_type: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_THREAT_ACTOR
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aThreatActor?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on ThreatActor {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aThreatActor.id);
  });

  it('can be used by an intrusion set', async () => {
    const anIntrusionSet = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'intrusion set',
        description: 'meant to test the uses relation with exploit',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_INTRUSION_SET
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: anIntrusionSet?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on IntrusionSet {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(anIntrusionSet.id);
  });

  it('can be used by a campaign', async () => {
    const aCampaign = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'campaign',
        description: 'meant to test the uses relation with exploit',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_CAMPAIGN
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aCampaign?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Campaign {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aCampaign.id);
  });

  it('can be used by a malware', async () => {
    const aMalware = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'malware',
        description: 'meant to test the uses relation with exploit',
        malware_types: [],
        is_family: false,
        architecture_execution_envs: [],
        implementation_languages: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_MALWARE
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aMalware?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Malware {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aMalware.id);
  });

  describe('update', () => {
    afterEach(async () => {
      await undoUpdate(exploitId);
    });

    it('can be updated', async () => {
      const newExploitName = 'modified name';
      const query: DocumentNode = gql`
        mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
          exploitFieldPatch(id: $id, input: $input) {
            name
          }
        }
      `;
      const variables = {
        id: exploitId,
        input: { key: 'name', value: [newExploitName] }
      };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploitFieldPatch.name).toEqual(newExploitName);
    });
  });
});
