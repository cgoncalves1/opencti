import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin, testContext } from '../../utils/testQuery';
import { createEntity, createRelation, deleteElementById } from '../../../src/database/middleware';
import {
  ENTITY_TYPE_ATTACK_PATTERN,
  ENTITY_TYPE_CAMPAIGN,
  ENTITY_TYPE_INTRUSION_SET,
  ENTITY_TYPE_MALWARE,
  ENTITY_TYPE_THREAT_ACTOR,
  ENTITY_TYPE_VULNERABILITY
} from '../../../src/schema/stixDomainObject';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';
import { ENTITY_TYPE_EXPLOIT } from '../../../src/modules/exploit/exploit-types';
import { listEntitiesPaginated, storeLoadById } from '../../../src/database/middleware-loader';
import { MARKING_TLP_GREEN } from '../../../src/schema/identifier';
import { EXPLOIT_DEFINITION } from '../../../src/modules/exploit/exploit';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../../../src/schema/general';
import type { BasicStoreEntity } from '../../../src/types/store';

const exploit = {
  stix_id: 'exploit--efb6fbec-d916-11ed-afa1-0242ac120002',
  name: 'an Exploit',
  description: 'an exploit description',
  published_date: '2023-01-16T15:54:59.194Z'
};

async function undoUpdate(exploitId: string): Promise<void> {
  const query: DocumentNode = gql`
    mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
      exploitFieldPatch(id: $id, input: $input) {
        id
      }
    }
  `;
  const variables = {
    id: exploitId,
    input: { key: 'name', value: [exploit.name] }
  };

  await queryAsAdmin({ query, variables });
}

async function findExploitByName(exploitName: string): Promise<BasicStoreEntity> {
  const anExploit = await listEntitiesPaginated(testContext, ADMIN_USER, [ENTITY_TYPE_EXPLOIT], { search: `"${exploitName}"` });

  return anExploit.edges[0].node;
}

async function createExploitWithName(name: string): Promise<void> {
  await createEntity(
    testContext,
    ADMIN_USER,
    {
      name,
      description: 'soon to be deleted',
      published_date: '2023-01-16T15:54:59.194Z'
    },
    ENTITY_TYPE_EXPLOIT
  );
}

describe('Exploit', () => {
  let exploitId: any;

  describe('attributes', () => {
    const attributeNames = EXPLOIT_DEFINITION.attributes.map((attribute) => attribute.name);

    it('has a name', () => {
      expect(attributeNames).toContain('name');
    });

    it('has a description', () => {
      expect(attributeNames).toContain('description');
    });

    it('has a published_date', () => {
      expect(attributeNames).toContain('published_date');
    });
  });

  it('can be created', async () => {
    const query: DocumentNode = gql`
      mutation ExploitCreation($input: ExploitAddInput!) {
        exploitAdd(input: $input) {
          id
          name
        }
      }
    `;

    const variables = { input: exploit };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitAdd.name).toEqual(exploit.name);

    exploitId = response.data?.exploitAdd.id;
  });

  describe('use deletable fixture', () => {
    const exploitName = 'exploit-test_fixture';

    beforeEach(async () => {
      await createExploitWithName(exploitName);
    });

    afterEach(async () => {
      const anExploit = await findExploitByName(exploitName);

      await deleteElementById(testContext, ADMIN_USER, anExploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);
    });

    it('is loaded from store with its stix id', async () => {
      const anExploit = await findExploitByName(exploitName);
      const query: DocumentNode = gql`
          query exploit($id: String!) {
              exploit(id: $id) {
                  id
              }
          }
      `;
      const variables = { id: anExploit.standard_id };

      const response: GraphQLResponse = await queryAsAdmin({ query, variables });

      expect(response.data?.exploit.id).toEqual(anExploit.id);
    });

    it('is loaded from store with its internal id', async () => {
      const anExploit = await findExploitByName(exploitName);
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            id
          }
        }
      `;
      const variables = { id: anExploit.id };

      const response: GraphQLResponse = await queryAsAdmin({ query, variables });

      expect(response.data?.exploit.id).toEqual(anExploit.id);
    });

    it('can be listed in a collection', async () => {
      const query: DocumentNode = gql`
        query listExploits($first: Int $after: ID $orderBy: ExploitsOrdering $orderMode: OrderingMode
          $filters: [ExploitsFiltering!] $filterMode: FilterMode $search: String) {
          exploits(first: $first after: $after orderBy: $orderBy orderMode: $orderMode
            filters: $filters filterMode: $filterMode search: $search) {
            edges {
              node {
                id
              }
            }
          }
        }
      `;
      const variables = { };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploits.edges.length).toEqual(2);
    });
  });

  describe('delete', () => {
    const exploitName = 'exploit-test_fixture';

    beforeEach(async () => {
      await createExploitWithName(exploitName);
    });

    afterEach(async () => {
      const anExploit = await listEntitiesPaginated(testContext, ADMIN_USER, [ENTITY_TYPE_EXPLOIT], { search: `"${exploitName}"` });

      if (anExploit.edges[0] !== undefined) {
        await deleteElementById(testContext, ADMIN_USER, anExploit.edges[0].node.id, ABSTRACT_STIX_DOMAIN_OBJECT);
      }
    });

    it('can be deleted', async () => {
      const anExploit = await findExploitByName(exploitName);

      const query: DocumentNode = gql`
        mutation ExploitDelete($id: ID!) {
          exploitDelete(id: $id)
        }
      `;
      const variables = { id: anExploit.id };

      await queryAsAdmin({ query, variables });
      const deletedExploit = await storeLoadById(testContext, ADMIN_USER, anExploit.id, ENTITY_TYPE_EXPLOIT);

      expect(deletedExploit).toBeUndefined();
    });
  });

  describe('attack pattern with deletable exploit fixture', () => {
    const exploitName = 'exploit-test_fixture';
    const attackPatternName = 'exploit-test_attack-pattern-fixture';

    beforeEach(async () => {
      await createExploitWithName(exploitName);

      await createEntity(
        testContext,
        ADMIN_USER,
        {
          name: attackPatternName,
          description: 'only meant to be used by an exploit',
          x_mitre_id: '',
          objectLabel: [],
          objectMarking: [],
          killChainPhases: [],
          externalReferences: []
        },
        ENTITY_TYPE_ATTACK_PATTERN
      );
    });

    afterEach(async () => {
      const anExploit = await findExploitByName(exploitName);

      await deleteElementById(testContext, ADMIN_USER, anExploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);

      const entity = await listEntitiesPaginated(testContext, ADMIN_USER, [ENTITY_TYPE_ATTACK_PATTERN], { search: `"${attackPatternName}"` });
      const anAttackPattern = entity.edges[0].node;

      await deleteElementById(testContext, ADMIN_USER, anAttackPattern.id, ABSTRACT_STIX_DOMAIN_OBJECT);
    });

    it('can use an attack pattern', async () => {
      const anExploit = await findExploitByName(exploitName);
      const entity = await listEntitiesPaginated(testContext, ADMIN_USER, [ENTITY_TYPE_ATTACK_PATTERN], { search: `"${attackPatternName}"` });
      const anAttackPattern = entity.edges[0].node;

      await createRelation(
        testContext,
        ADMIN_USER,
        {
          relationship_type: RELATION_USES,
          fromId: anExploit.id,
          toId: anAttackPattern.id,
        }
      );

      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  to {
                    ... on AttackPattern {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploit.id };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

      expect(relationsId).toContain(anAttackPattern.id);
    });
  });

  it('can target a vulnerability', async () => {
    const aVulnerability = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'vulnerability targeted by exploit',
        description: 'meant to test the target relation with exploit',
        x_opencti_base_score: 1,
        x_opencti_base_severity: '',
        x_opencti_attack_vector: '',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_VULNERABILITY
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_TARGETS,
        fromId: exploitId,
        toId: aVulnerability?.id,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on Vulnerability {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(aVulnerability.id);
  });

  it('can be used by a threat actor', async () => {
    const aThreatActor = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'threat actor that uses exploit',
        description: 'meant to test the uses relation with exploit',
        threat_actor_type: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_THREAT_ACTOR
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aThreatActor?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on ThreatActor {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aThreatActor.id);
  });

  it('can be used by an intrusion set', async () => {
    const anIntrusionSet = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'intrusion set that uses exploit',
        description: 'meant to test the uses relation with exploit',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_INTRUSION_SET
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: anIntrusionSet?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on IntrusionSet {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(anIntrusionSet.id);
  });

  it('can be used by a campaign', async () => {
    const aCampaign = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'campaign that uses exploit',
        description: 'meant to test the uses relation with exploit',
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_CAMPAIGN
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aCampaign?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Campaign {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aCampaign.id);
  });

  it('can be used by a malware', async () => {
    const aMalware = await createEntity(
      testContext,
      ADMIN_USER,
      {
        name: 'malware that uses exlpoit',
        description: 'meant to test the uses relation with exploit',
        malware_types: [],
        is_family: false,
        architecture_execution_envs: [],
        implementation_languages: [],
        confidence: 75,
        objectMarking: [],
        objectLabel: [],
        externalReferences: []
      },
      ENTITY_TYPE_MALWARE
    );

    await createRelation(
      testContext,
      ADMIN_USER,
      {
        relationship_type: RELATION_USES,
        fromId: aMalware?.id,
        toId: exploitId,
      }
    );

    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Malware {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: exploitId };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aMalware.id);
  });

  describe('update', () => {
    afterEach(async () => {
      await undoUpdate(exploitId);
    });

    it('can be updated', async () => {
      const newExploitName = 'modified name';
      const query: DocumentNode = gql`
        mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
          exploitFieldPatch(id: $id, input: $input) {
            name
          }
        }
      `;
      const variables = {
        id: exploitId,
        input: { key: 'name', value: [newExploitName] }
      };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploitFieldPatch.name).toEqual(newExploitName);
    });
  });

  it('can have its context updated', async () => {
    const query: DocumentNode = gql`
      mutation UpdateExploitContext($id: ID!, $input: EditContext!) {
        exploitContextPatch(id: $id, input: $input) {
          id
        }
      }
    `;
    const variables = {
      id: exploitId,
      input: { focusOn: 'description' }
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitContextPatch.id).toEqual(exploitId);
  });

  it('can have its context cleaned', async () => {
    const query: DocumentNode = gql`
      mutation cleanExploitContext($id: ID!) {
        exploitContextClean(id: $id) {
          id
        }
      }
    `;
    const variables = { id: exploitId };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitContextClean.id).toEqual(exploitId);
  });

  it('can have references', async () => {
    const query: DocumentNode = gql`
      mutation AddSomeReferencesToExploit($id: ID!, $input: StixRefRelationshipAddInput!) {
        exploitRelationAdd(id: $id, input: $input) {
          id
          from {
            ... on Exploit {
              objectMarking {
                edges {
                  node {
                    definition
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = {
      id: exploitId,
      input: {
        toId: MARKING_TLP_GREEN,
        relationship_type: 'object-marking'
      }
    };

    const response = await queryAsAdmin({ query, variables });
    const markingDefinitions = response.data?.exploitRelationAdd.from.objectMarking.edges.map((marking) => marking.node.definition);

    expect(markingDefinitions).toContain('TLP:GREEN');
  });

  it('can delete its references', async () => {
    const query: DocumentNode = gql`
      mutation DeleteExploitMarkingReference($id: ID!, $toId: StixRef!, $relationship_type: String!) {
        exploitRelationDelete(id: $id, toId: $toId, relationship_type: $relationship_type) {
          id
          objectMarking {
            edges {
              node {
                definition
              }
            }
          }
        }
      }
    `;
    const variables = {
      id: exploitId,
      toId: MARKING_TLP_GREEN,
      relationship_type: 'object-marking'
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitRelationDelete.objectMarking.edges).to.have.length(0);
  });
});
