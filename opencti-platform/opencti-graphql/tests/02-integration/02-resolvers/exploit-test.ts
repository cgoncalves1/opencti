import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin, testContext } from '../../utils/testQuery';
import { createEntity, createRelation, deleteElementById } from '../../../src/database/middleware';
import {
  ENTITY_TYPE_ATTACK_PATTERN,
  ENTITY_TYPE_CAMPAIGN,
  ENTITY_TYPE_INTRUSION_SET,
  ENTITY_TYPE_MALWARE,
  ENTITY_TYPE_THREAT_ACTOR,
  ENTITY_TYPE_VULNERABILITY
} from '../../../src/schema/stixDomainObject';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';
import { BasicStoreEntityExploit, ENTITY_TYPE_EXPLOIT } from '../../../src/modules/exploit/exploit-types';
import { listEntitiesPaginated, storeLoadById } from '../../../src/database/middleware-loader';
import { MARKING_TLP_GREEN } from '../../../src/schema/identifier';
import { EXPLOIT_DEFINITION } from '../../../src/modules/exploit/exploit';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../../../src/schema/general';

const exploit = {
  stix_id: 'exploit--efb6fbec-d916-11ed-afa1-0242ac120002',
  name: 'an Exploit',
  description: 'an exploit description',
  published_date: '2023-01-16T15:54:59.194Z'
};

async function undoUpdate(exploitId: string): Promise<void> {
  const query: DocumentNode = gql`
    mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
      exploitFieldPatch(id: $id, input: $input) {
        id
      }
    }
  `;
  const variables = {
    id: exploitId,
    input: { key: 'name', value: [exploit.name] }
  };

  await queryAsAdmin({ query, variables });
}

async function findEntity(entityName: string, entityType: any) {
  const entity = await listEntitiesPaginated(testContext, ADMIN_USER, [entityType], { search: `"${entityName}"` });

  return entity.edges[0].node;
}

async function relates(fromId: string, relationship_type: string, toId: string) {
  await createRelation(testContext, ADMIN_USER, { relationship_type, fromId, toId });
}

async function deleteEntity(entityName: string, entityType: string): Promise<void> {
  const entity = await findEntity(entityName, entityType);

  await deleteElementById(testContext, ADMIN_USER, entity.id, ABSTRACT_STIX_DOMAIN_OBJECT);
}

async function createExploitWithName(name: string): Promise<BasicStoreEntityExploit> {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name,
      description: '',
      published_date: '2023-01-16T15:54:59.194Z'
    },
    ENTITY_TYPE_EXPLOIT
  );
}

async function createAttackPatternWithName(attackPatternName: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name: attackPatternName,
      description: '',
      x_mitre_id: '',
      objectLabel: [],
      objectMarking: [],
      killChainPhases: [],
      externalReferences: []
    },
    ENTITY_TYPE_ATTACK_PATTERN
  );
}

async function createThreatActorWithName(threatActorName: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name: threatActorName,
      description: '',
      threat_actor_type: [],
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    },
    ENTITY_TYPE_THREAT_ACTOR
  );
}

async function createVulnerabilityWithName(vulnerabilityName: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name: vulnerabilityName,
      description: '',
      x_opencti_base_score: 1,
      x_opencti_base_severity: '',
      x_opencti_attack_vector: '',
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    },
    ENTITY_TYPE_VULNERABILITY
  );
}

async function createIntrusionSetWithName(name: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name,
      description: '',
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    },
    ENTITY_TYPE_INTRUSION_SET
  );
}

async function createCampaignWithName(name: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name,
      description: '',
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    },
    ENTITY_TYPE_CAMPAIGN
  );
}

async function createMalwareWithName(malwareName: string) {
  return createEntity(
    testContext,
    ADMIN_USER,
    {
      name: malwareName,
      description: '',
      malware_types: [],
      is_family: false,
      architecture_execution_envs: [],
      implementation_languages: [],
      confidence: 75,
      objectMarking: [],
      objectLabel: [],
      externalReferences: []
    },
    ENTITY_TYPE_MALWARE
  );
}

describe('Exploit', () => {
  let exploitIdForCreation: any;

  describe('attributes', () => {
    const attributeNames = EXPLOIT_DEFINITION.attributes.map((attribute) => attribute.name);

    it('has a name', () => {
      expect(attributeNames).toContain('name');
    });

    it('has a description', () => {
      expect(attributeNames).toContain('description');
    });

    it('has a published_date', () => {
      expect(attributeNames).toContain('published_date');
    });
  });

  it('can be created', async () => {
    const query: DocumentNode = gql`
      mutation ExploitCreation($input: ExploitAddInput!) {
        exploitAdd(input: $input) {
          id
          name
        }
      }
    `;

    const variables = { input: exploit };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitAdd.name).toEqual(exploit.name);

    exploitIdForCreation = response.data?.exploitAdd.id;
  });

  describe('use deletable fixture', () => {
    const exploitName = 'exploit-test_exploit-fixture';

    beforeEach(async () => {
      await createExploitWithName(exploitName);
    });

    afterEach(async () => {
      const anExploit = await findEntity(exploitName, ENTITY_TYPE_EXPLOIT);

      await deleteElementById(testContext, ADMIN_USER, anExploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);
    });

    it('is loaded from store with its stix id', async () => {
      const anExploit = await findEntity(exploitName, ENTITY_TYPE_EXPLOIT);
      const query: DocumentNode = gql`
          query exploit($id: String!) {
              exploit(id: $id) {
                  id
              }
          }
      `;
      const variables = { id: anExploit.standard_id };

      const response: GraphQLResponse = await queryAsAdmin({ query, variables });

      expect(response.data?.exploit.id).toEqual(anExploit.id);
    });

    it('is loaded from store with its internal id', async () => {
      const anExploit = await findEntity(exploitName, ENTITY_TYPE_EXPLOIT);
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            id
          }
        }
      `;
      const variables = { id: anExploit.id };

      const response: GraphQLResponse = await queryAsAdmin({ query, variables });

      expect(response.data?.exploit.id).toEqual(anExploit.id);
    });

    it('can be listed in a collection', async () => {
      const query: DocumentNode = gql`
        query listExploits($first: Int $after: ID $orderBy: ExploitsOrdering $orderMode: OrderingMode
          $filters: [ExploitsFiltering!] $filterMode: FilterMode $search: String) {
          exploits(first: $first after: $after orderBy: $orderBy orderMode: $orderMode
            filters: $filters filterMode: $filterMode search: $search) {
            edges {
              node {
                id
              }
            }
          }
        }
      `;
      const variables = { };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploits.edges.length).toEqual(2);
    });
  });

  describe('delete with deletable fixtures', () => {
    const exploitName = 'exploit-test_exploit-fixture';

    beforeEach(async () => {
      await createExploitWithName(exploitName);
    });

    afterEach(async () => {
      const anExploit = await listEntitiesPaginated(testContext, ADMIN_USER, [ENTITY_TYPE_EXPLOIT], { search: `"${exploitName}"` });

      if (anExploit.edges[0] !== undefined) {
        await deleteElementById(testContext, ADMIN_USER, anExploit.edges[0].node.id, ABSTRACT_STIX_DOMAIN_OBJECT);
      }
    });

    it('can be deleted', async () => {
      const anExploit = await findEntity(exploitName, ENTITY_TYPE_EXPLOIT);

      const query: DocumentNode = gql`
        mutation ExploitDelete($id: ID!) {
          exploitDelete(id: $id)
        }
      `;
      const variables = { id: anExploit.id };

      await queryAsAdmin({ query, variables });
      const deletedExploit = await storeLoadById(testContext, ADMIN_USER, anExploit.id, ENTITY_TYPE_EXPLOIT);

      expect(deletedExploit).toBeUndefined();
    });
  });

  describe('test relation deletable fixture', () => {
    let anExploitId: string;
    let aThreatActorId: string;
    let aVulnerabilityId: string;
    let anAttackPatternId: string;
    let anIntrusionSetId: string;
    let aCampaignId: string;
    let aMalwareId: string;

    beforeEach(async () => {
      anExploitId = (await createExploitWithName('exploit-test_exploit-fixture')).id;

      aThreatActorId = (await createThreatActorWithName('exploit-test_threat-actor-fixture')).id;
      await relates(aThreatActorId, RELATION_USES, anExploitId);

      aVulnerabilityId = (await createVulnerabilityWithName('exploit-test_vulnerability-fixture')).id;
      await relates(anExploitId, RELATION_TARGETS, aVulnerabilityId);

      anAttackPatternId = (await createAttackPatternWithName('exploit-test_attack-pattern-fixture')).id;
      await relates(anExploitId, RELATION_USES, anAttackPatternId);

      anIntrusionSetId = (await createIntrusionSetWithName('exploit-test_intrusion-set-fixture')).id;
      await relates(anIntrusionSetId, RELATION_USES, anExploitId);

      aCampaignId = (await createCampaignWithName('exploit-test_campaign-fixture')).id;
      await relates(aCampaignId, RELATION_USES, anExploitId);

      aMalwareId = (await createMalwareWithName('exploit-test_malware-fixture')).id;
      await relates(aMalwareId, RELATION_USES, anExploitId);
    });

    afterEach(async () => {
      await deleteElementById(testContext, ADMIN_USER, anExploitId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, aThreatActorId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, aVulnerabilityId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, anAttackPatternId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, anIntrusionSetId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, aCampaignId, ABSTRACT_STIX_DOMAIN_OBJECT);
      await deleteElementById(testContext, ADMIN_USER, aMalwareId, ABSTRACT_STIX_DOMAIN_OBJECT);
    });

    it('can be used by a threat actor', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  from {
                    ... on ThreatActor {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

      expect(fromRelationsId).toContain(aThreatActorId);
    });

    it('can target a vulnerability', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  to {
                    ... on Vulnerability {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

      expect(relationsId).toContain(aVulnerabilityId);
    });

    it('can use an attack pattern', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  to {
                    ... on AttackPattern {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

      expect(relationsId).toContain(anAttackPatternId);
    });

    it('can be used by an intrusion set', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  from {
                    ... on IntrusionSet {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

      expect(fromRelationsId).toContain(anIntrusionSetId);
    });

    it('can be used by a campaign', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  from {
                    ... on Campaign {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

      expect(fromRelationsId).toContain(aCampaignId);
    });

    it('can be used by a malware', async () => {
      const query: DocumentNode = gql`
        query exploit($id: String!) {
          exploit(id: $id) {
            stixCoreRelationships {
              edges {
                node {
                  from {
                    ... on Malware {
                      id
                    }
                  }
                }
              }
            }
          }
        }
      `;
      const variables = { id: anExploitId };
      const response: GraphQLResponse = await queryAsAdmin({ query, variables });
      const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

      expect(fromRelationsId).toContain(aMalwareId);
    });
  });

  describe('update', () => {
    afterEach(async () => {
      await undoUpdate(exploitIdForCreation);
    });

    it('can be updated', async () => {
      const newExploitName = 'modified name';
      const query: DocumentNode = gql`
        mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
          exploitFieldPatch(id: $id, input: $input) {
            name
          }
        }
      `;
      const variables = {
        id: exploitIdForCreation,
        input: { key: 'name', value: [newExploitName] }
      };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploitFieldPatch.name).toEqual(newExploitName);
    });
  });

  it('can have its context updated', async () => {
    const query: DocumentNode = gql`
      mutation UpdateExploitContext($id: ID!, $input: EditContext!) {
        exploitContextPatch(id: $id, input: $input) {
          id
        }
      }
    `;
    const variables = {
      id: exploitIdForCreation,
      input: { focusOn: 'description' }
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitContextPatch.id).toEqual(exploitIdForCreation);
  });

  it('can have references', async () => {
    const query: DocumentNode = gql`
      mutation AddSomeReferencesToExploit($id: ID!, $input: StixRefRelationshipAddInput!) {
        exploitRelationAdd(id: $id, input: $input) {
          id
          from {
            ... on Exploit {
              objectMarking {
                edges {
                  node {
                    definition
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = {
      id: exploitIdForCreation,
      input: {
        toId: MARKING_TLP_GREEN,
        relationship_type: 'object-marking'
      }
    };

    const response = await queryAsAdmin({ query, variables });
    const markingDefinitions = response.data?.exploitRelationAdd.from.objectMarking.edges.map((marking) => marking.node.definition);

    expect(markingDefinitions).toContain('TLP:GREEN');
  });

  it('can delete its references', async () => {
    const query: DocumentNode = gql`
      mutation DeleteExploitMarkingReference($id: ID!, $toId: StixRef!, $relationship_type: String!) {
        exploitRelationDelete(id: $id, toId: $toId, relationship_type: $relationship_type) {
          id
        }
      }
    `;
    const variables = {
      id: exploitIdForCreation,
      toId: MARKING_TLP_GREEN,
      relationship_type: 'object-marking'
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitRelationDelete.objectMarking.edges).to.have.length(0);
  });
});
