import type { DocumentNode } from 'graphql/index';
import gql from 'graphql-tag';
import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it } from 'vitest';
import type { GraphQLResponse } from 'apollo-server-core';
import { ADMIN_USER, queryAsAdmin, testContext } from '../../utils/testQuery';
import { createRelation, deleteElementById } from '../../../src/database/middleware';
import { RELATION_TARGETS, RELATION_USES } from '../../../src/schema/stixCoreRelationship';
import { BasicStoreEntityExploit, ENTITY_TYPE_EXPLOIT } from '../../../src/modules/exploit/exploit-types';
import { listEntitiesPaginated, storeLoadById } from '../../../src/database/middleware-loader';
import { EXPLOIT_DEFINITION } from '../../../src/modules/exploit/exploit';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../../../src/schema/general';
import {
  createAttackPatternWithName,
  createCampaignWithName,
  createExploitWithName,
  createIntrusionSetWithName,
  createMalwareWithName,
  createMarking,
  createThreatActorWithName,
  createVulnerabilityWithName
} from './exploit-test-fixtures';
import { ENTITY_TYPE_MARKING_DEFINITION } from '../../../src/schema/stixMetaObject';
import type { BasicStoreEntity } from '../../../src/types/store';
import type { MarkingDefinition } from '../../../src/generated/graphql';

async function findEntityByName(entityName: string, entityType: any): Promise<BasicStoreEntity | undefined> {
  const entity = await listEntitiesPaginated(testContext, ADMIN_USER, [entityType], { search: `"${entityName}"` });

  return entity.edges.length >= 0 ? entity.edges[0].node : undefined;
}

async function relates(fromId: string, relationship_type: string, toId: string) {
  await createRelation(testContext, ADMIN_USER, { relationship_type, fromId, toId });
}

describe('Exploit', () => {
  let anExploit: BasicStoreEntityExploit;
  let marking: MarkingDefinition;
  let aThreatActorId: string;
  let aVulnerabilityId: string;
  let anAttackPatternId: string;
  let anIntrusionSetId: string;
  let aCampaignId: string;
  let aMalwareId: string;

  beforeAll(async () => {
    anExploit = await createExploitWithName('exploit-test_exploit-fixture');

    marking = await createMarking();

    aThreatActorId = (await createThreatActorWithName('exploit-test_threat-actor-fixture')).id;
    await relates(aThreatActorId, RELATION_USES, anExploit.id);

    aVulnerabilityId = (await createVulnerabilityWithName('exploit-test_vulnerability-fixture')).id;
    await relates(anExploit.id, RELATION_TARGETS, aVulnerabilityId);

    anAttackPatternId = (await createAttackPatternWithName('exploit-test_attack-pattern-fixture')).id;
    await relates(anExploit.id, RELATION_USES, anAttackPatternId);

    anIntrusionSetId = (await createIntrusionSetWithName('exploit-test_intrusion-set-fixture')).id;
    await relates(anIntrusionSetId, RELATION_USES, anExploit.id);

    aCampaignId = (await createCampaignWithName('exploit-test_campaign-fixture')).id;
    await relates(aCampaignId, RELATION_USES, anExploit.id);

    aMalwareId = (await createMalwareWithName('exploit-test_malware-fixture')).id;
    await relates(aMalwareId, RELATION_USES, anExploit.id);
  });

  afterAll(async () => {
    await deleteElementById(testContext, ADMIN_USER, anExploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);

    await deleteElementById(testContext, ADMIN_USER, marking.id, ENTITY_TYPE_MARKING_DEFINITION);

    await deleteElementById(testContext, ADMIN_USER, aThreatActorId, ABSTRACT_STIX_DOMAIN_OBJECT);
    await deleteElementById(testContext, ADMIN_USER, aVulnerabilityId, ABSTRACT_STIX_DOMAIN_OBJECT);
    await deleteElementById(testContext, ADMIN_USER, anAttackPatternId, ABSTRACT_STIX_DOMAIN_OBJECT);
    await deleteElementById(testContext, ADMIN_USER, anIntrusionSetId, ABSTRACT_STIX_DOMAIN_OBJECT);
    await deleteElementById(testContext, ADMIN_USER, aCampaignId, ABSTRACT_STIX_DOMAIN_OBJECT);
    await deleteElementById(testContext, ADMIN_USER, aMalwareId, ABSTRACT_STIX_DOMAIN_OBJECT);
  });

  describe('attributes', () => {
    const attributeNames = EXPLOIT_DEFINITION.attributes.map((attribute) => attribute.name);

    it('has a name', () => {
      expect(attributeNames).toContain('name');
    });

    it('has a description', () => {
      expect(attributeNames).toContain('description');
    });

    it('has a published_date', () => {
      expect(attributeNames).toContain('published_date');
    });
  });

  describe('creation', () => {
    const exploitName = 'an Exploit';

    afterEach(async () => {
      const exploit = await findEntityByName(exploitName, ENTITY_TYPE_EXPLOIT);

      if (exploit !== undefined) {
        await deleteElementById(testContext, ADMIN_USER, exploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);
      }
    });

    it('can be created', async () => {
      const exploit = {
        name: exploitName,
        description: 'an exploit description',
        published_date: '2023-01-16T15:54:59.194Z'
      };

      const query: DocumentNode = gql`
        mutation ExploitCreation($input: ExploitAddInput!) {
          exploitAdd(input: $input) {
            id
            name
          }
        }
      `;
      const variables = { input: exploit };

      const response = await queryAsAdmin({ query, variables });

      expect(response.data?.exploitAdd.name).toEqual(exploitName);
    });
  });

  describe('deletion', () => {
    let anExploit: BasicStoreEntityExploit;

    beforeEach(async () => {
      anExploit = await createExploitWithName('exploit-test_exploit-for-deletion-fixture');
    });

    afterEach(async () => {
      const exploit = await storeLoadById(testContext, ADMIN_USER, anExploit.id, ENTITY_TYPE_EXPLOIT);

      if (exploit !== undefined) {
        await deleteElementById(testContext, ADMIN_USER, anExploit.id, ABSTRACT_STIX_DOMAIN_OBJECT);
      }
    });

    it('can be deleted', async () => {
      const query: DocumentNode = gql`
        mutation ExploitDelete($id: ID!) {
          exploitDelete(id: $id)
        }
      `;
      const variables = { id: anExploit.id };

      await queryAsAdmin({ query, variables });
      const deletedExploit = await storeLoadById(testContext, ADMIN_USER, anExploit.id, ENTITY_TYPE_EXPLOIT);

      expect(deletedExploit).toBeUndefined();
    });
  });

  it('is loaded from store with its stix id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: anExploit.standard_id };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(anExploit.id);
  });

  it('is loaded from store with its internal id', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          id
        }
      }
    `;
    const variables = { id: anExploit.id };

    const response: GraphQLResponse = await queryAsAdmin({ query, variables });

    expect(response.data?.exploit.id).toEqual(anExploit.id);
  });

  it('can be listed in a collection', async () => {
    const query: DocumentNode = gql`
      query listExploits($first: Int $after: ID $orderBy: ExploitsOrdering $orderMode: OrderingMode
        $filters: [ExploitsFiltering!] $filterMode: FilterMode $search: String) {
        exploits(first: $first after: $after orderBy: $orderBy orderMode: $orderMode
          filters: $filters filterMode: $filterMode search: $search) {
          edges {
            node {
              id
            }
          }
        }
      }
    `;
    const variables = { };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploits.edges.length).toEqual(1);
  });

  it('can have its context updated', async () => {
    const query: DocumentNode = gql`
      mutation UpdateExploitContext($id: ID!, $input: EditContext!) {
        exploitContextPatch(id: $id, input: $input) {
          id
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      input: { focusOn: 'description' }
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitContextPatch.id).toEqual(anExploit.id);
  });

  it('can be updated', async () => {
    const newExploitName = 'modified name';
    const query: DocumentNode = gql`
      mutation UpdateExploitName($id: ID!, $input: [EditInput]!) {
        exploitFieldPatch(id: $id, input: $input) {
          name
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      input: { key: 'name', value: [newExploitName] }
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitFieldPatch.name).toEqual(newExploitName);
  });

  it('can have references', async () => {
    const query: DocumentNode = gql`
      mutation AddSomeReferencesToExploit($id: ID!, $input: StixRefRelationshipAddInput!) {
        exploitRelationAdd(id: $id, input: $input) {
          id
          from {
            ... on Exploit {
              objectMarking {
                edges {
                  node {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      input: {
        toId: marking.id,
        relationship_type: 'object-marking'
      }
    };

    const response = await queryAsAdmin({ query, variables });

    const markingDefinitions = response.data?.exploitRelationAdd.from.objectMarking.edges[0].node.id;

    expect(markingDefinitions).toEqual(marking.id);
  });

  it('can delete its references', async () => {
    const query: DocumentNode = gql`
      mutation DeleteExploitMarkingReference($id: ID!, $toId: StixRef!, $relationship_type: String!) {
        exploitRelationDelete(id: $id, toId: $toId, relationship_type: $relationship_type) {
          id
        }
      }
    `;
    const variables = {
      id: anExploit.id,
      toId: marking.id,
      relationship_type: 'object-marking'
    };

    const response = await queryAsAdmin({ query, variables });

    expect(response.data?.exploitRelationDelete.id).toEqual(anExploit.id);
  });

  it('can be used by a threat actor', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on ThreatActor {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aThreatActorId);
  });

  it('can target a vulnerability', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on Vulnerability {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(aVulnerabilityId);
  });

  it('can use an attack pattern', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                to {
                  ... on AttackPattern {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const relationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { to: { id: any; }; }; }) => relation.node.to.id);

    expect(relationsId).toContain(anAttackPatternId);
  });

  it('can be used by an intrusion set', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on IntrusionSet {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(anIntrusionSetId);
  });

  it('can be used by a campaign', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Campaign {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aCampaignId);
  });

  it('can be used by a malware', async () => {
    const query: DocumentNode = gql`
      query exploit($id: String!) {
        exploit(id: $id) {
          stixCoreRelationships {
            edges {
              node {
                from {
                  ... on Malware {
                    id
                  }
                }
              }
            }
          }
        }
      }
    `;
    const variables = { id: anExploit.id };
    const response: GraphQLResponse = await queryAsAdmin({ query, variables });
    const fromRelationsId = response.data?.exploit.stixCoreRelationships.edges.map((relation: { node: { from: { id: any; }; }; }) => relation.node.from.id);

    expect(fromRelationsId).toContain(aMalwareId);
  });
});
